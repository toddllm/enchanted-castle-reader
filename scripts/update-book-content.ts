import { promises as fs } from 'node:fs';
import path from 'node:path';

type IllustrationScene = {
  id: string;
  description: string;
  placement?: string;
  path: string;
  anchor?: string;
};

type IllustrationChapter = {
  chapterId: number;
  title: string;
  scenes: IllustrationScene[];
};

type IllustrationsData = {
  chapters: IllustrationChapter[];
};

const bookPath = path.resolve(process.cwd(), 'content', 'book.txt');
const illustrationsPath = path.resolve(
  process.cwd(),
  'client',
  'src',
  'data',
  'illustrations.json'
);
const outputPath = path.resolve(
  process.cwd(),
  'client',
  'src',
  'lib',
  'book-content.ts'
);

const romanToInt = (roman: string) => {
  const map: Record<string, number> = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000
  };
  let total = 0;
  let prev = 0;
  for (const char of roman.split('').reverse()) {
    const value = map[char] || 0;
    if (value < prev) {
      total -= value;
    } else {
      total += value;
      prev = value;
    }
  }
  return total;
};

const loadIllustrations = async () => {
  const raw = await fs.readFile(illustrationsPath, 'utf8');
  return JSON.parse(raw) as IllustrationsData;
};

const buildPanelBlock = (sceneId: string) =>
  `<comic-panel id="${sceneId}">\n</comic-panel>`;

const insertPanels = (body: string, scenes: IllustrationScene[]) => {
  if (!scenes || scenes.length === 0) {
    return body;
  }

  const paragraphs = body
    .split(/\n\n+/)
    .map((paragraph) => paragraph.trim())
    .filter(Boolean);

  const placements = scenes.map((scene, index) => {
    if (scene.anchor) {
      const anchorIndex = paragraphs.findIndex((paragraph) =>
        paragraph.includes(scene.anchor as string)
      );
      if (anchorIndex !== -1) {
        return { scene, index: anchorIndex + 1 };
      }
      console.warn(
        `Anchor not found for ${scene.id}; falling back to distributed placement.`
      );
    }

    const rawIndex = Math.round(
      ((index + 1) / (scenes.length + 1)) * paragraphs.length
    );
    const clamped = Math.min(Math.max(rawIndex, 1), paragraphs.length);
    return { scene, index: clamped };
  });

  placements.sort((a, b) => a.index - b.index);

  let offset = 0;
  placements.forEach((placement) => {
    const insertIndex = Math.min(placement.index + offset, paragraphs.length);
    paragraphs.splice(insertIndex, 0, buildPanelBlock(placement.scene.id));
    offset += 1;
  });

  return paragraphs.join('\n\n');
};

const main = async () => {
  const baseText = await fs.readFile(bookPath, 'utf8');
  const illustrations = await loadIllustrations();
  const scenesByChapter = new Map<number, IllustrationScene[]>();

  illustrations.chapters.forEach((chapter) => {
    scenesByChapter.set(chapter.chapterId, chapter.scenes || []);
  });

  const chapters = baseText
    .replace(/\r/g, '')
    .split(/(?=CHAPTER [IVX]+)/g)
    .map((chunk) => chunk.trim())
    .filter(Boolean);

  const injectedChapters = chapters.map((chapterText) => {
    const titleMatch = chapterText.match(/CHAPTER ([IVX]+)/);
    const chapterTitle = titleMatch ? titleMatch[0] : 'CHAPTER';
    const chapterNumber = titleMatch ? romanToInt(titleMatch[1]) : 0;
    const chapterBody = chapterText.replace(/CHAPTER [IVX]+[\s\n]*/, '');
    const scenes = scenesByChapter.get(chapterNumber) ?? [];
    const updatedBody = insertPanels(chapterBody, scenes);
    return `${chapterTitle}\n\n${updatedBody}`.trim();
  });

  const updatedText = injectedChapters.join('\n\n');

  const fileContents = `// This file is generated by scripts/update-book-content.ts.\n` +
    `// Run scripts/extract-gutenberg.ts to update content/book.txt.\n` +
    `export const rawBookContent = ${JSON.stringify(updatedText)};\n`;

  await fs.writeFile(outputPath, fileContents, 'utf8');
  console.log(`Wrote ${outputPath}`);
};

await main();
